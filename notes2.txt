# ------------------------------------------------------
# Installing Django Rest Framework
- pipenv install djangorestframework
- add 'rest_framework' in the INSTALLED_APPS

# ------------------------------------------------------
# Creating API views
- create a urls.py file
- In views create a function
- register the route in urls.py

- from rest_framework.decorators import api_view
- from rest_framework.response import Response
- @api_view()
    def product_list(request):
        return Response('ok')

- Flow: create views then add it in urls.py (route)

# ------------------------------------------------------
# Creating Serializers
- Converts a model instance to a dictionary
- search django rest framework serializers for more information

- create serializers.py file in the app
- from rest_framework import serializers
- it is like defining a model with fields (make sure it is the same fields with the model)

# ------------------------------------------------------
# Serializing Objects

# The default object result presentation is in String. Add COERCE_DECIMAL_TO_STRING to convert decimal value fields from string to decimal
- In settings
- REST_FRAMEWORK = {
    'COERCE_DECIMAL_TO_STRING': False
}

# Get object return 404 if not found
- from django.shortcuts import get_object_or_404 # used to get the object and return 404 if not found
- set many to True to iterate over the queryset (many=True)
- serializer = PackageSerializer(queryset, many=True)

# ------------------------------------------------------

# Creating Custom Serializer Fields

- create a new field -- Use serializers.SerializerMethodField(method_name='')
    price_with_discount = serializers.SerializerMethodField(method_name='calculate_discount')

- create a function add put it in the method name
    def calculate_discount(self, package):
        return package.price - (package.price * Decimal(.10))

# To rename a field make the source of the field to its real field name in the model
    package_price = serializers.DecimalField(max_digits=10, decimal_places=2, source='price') -- price -> package_price, source='price'


# ------------------------------------------------------

# Serializing Relationships

- Watch lesson 13 in Django Part 2
- 4 ways to serialize Relationships
- Primary key
- String
- Nested Object
- Hyperlink (complicated)

# ------------------------------------------------------

# Model Serializer

- better implementation of Serializer

- class PackageSerializer(serializers.ModelSerializer):
    class Meta:
        model = Package
        fields = ['title', 'package_type', 'price', 'price_with_discount']

# ------------------------------------------------------

# Deserializing Data and Saving Objects

 - Adding get, put, patch, delete in @api_view(['GET', 'PUT'])
 - check if request.method is equal to the CRUD operations -- if request.method == "GET":
 - serializer.is_valid(raise_exception=True) # Deserializing Data
 - serializer.save() # Save the data
 - return Response(serializer.data, status=status.HTTP_200_OK)

# ------------------------------------------------------

# DELETING OBJECTS

- get the item e.g package = get_object_or_404(Package, pk=id)
- if request.method == 'DELETE':
- package.delete()
- return Response(status.HTTP_204_NO_CONTENT)

# If the object cannot be deleted, check the object if it is associated with other collections/Relationships

# ------------------------------------------------------

# ADVANCED API CONCEPTS

- Class-based views
- Generic views
- Viewsets
- Routers
- Searching, filtering and pagination

# ------------------------------------------------------

# API Views

- from rest_framework.views import APIView
- converting function based view into Class based views
- change the path in urls.py --- path('package/', views.PackageList.as_view())
- check views.py for the changes

# ------------------------------------------------------

# Model Mixins

- from rest_framework.mixins import ListModelMixin, CreateModelMixin
- Improved class based views
- check the mixins implementation for more information -- lesson 22 in django part 2

- didn't use the model mixins
- uses generic views (better version)

# ------------------------------------------------------

# Generic Views

- from rest_framework.generics import ListCreateAPIView
- search search django rest_framework api guide generic views
- Use Concrete View Classes
- Concrete class combines 2 or more mixins

# ListCreateAPIView

# Basic Implementation

- queryset = Package.objects.all()
- serializer_class = PackageSerializer

# overwrite the get_queryset and get_serializer_class, and get_serializer_context --- USE IF YOU HAVE A LOGIC NEEDED E.G IF CONDITIONS

- def get_queryset(self):
    return Package.objects.all()
    
- def get_serializer_class(self):
    return PackageSerializer            #class -- remove the () - with parenthesis, it's a function

- def get_serializer_context(self):
        return {'request': self.request} - return the context object

- You can now delete the 'get' and 'post' function because ListCreateAPIView has a built in list and create api views
- much cleaner and much conscise compared to base APIView

# Note: IF YOU HAVE A CUSTOM FIELD LIKE 'Products_Count' IN THE SERIALIZER MAKE IT 'read_ony=True' TO AVOID PROBLEM

- products_count = serializer.IntegerField(read_ony=True)

# ------------------------------------------------------

# Customizing Generic Views

- from rest_framework.generics import ListCreateAPIView, RetrieveUpdateDestroyAPIView
- check the implementation of each class, if it can get, patch, put, delete

- In urls.py, if you encounter an error URL keyword argument named 'pk'. Change the 'path('package/<int:pk>/', views.PackageDetail.as_view())' 
    or add (lookup_field = 'id') in the class views IF <int:id> ---- path('package/<int:id>/', views.PackageDetail.as_view())
- use 'pk' instead of 'id'


# To customize the generic view

- overwrite the existing function like the delete
- def delete(self, request, id):
        package = get_object_or_404(Package, pk=id)
        package.delete()
        return Response(status=status.HTTP_204_NO_CONTENT)

# ------------------------------------------------------

# Model View Set -- Single class end point (CRUD endpoints)

- from rest_framework.viewsets import ModelViewSet

- has multiple APIView like get, retrieve, update and delete
- used to combine the logic of multiple views
- analyze the changes in views.py. The PackgeList and PackageDetail are combined using model view set

# IF YOU DONT NEED WRITE OPERATIONS (PUT, PATCH, POST, DELETE) ONLY 'GET' METHOD

- from rest_framework.viewsets import ReadOnlyModelViewSet
- read only operations

# NOTE: THE PACKAGE ENDPOINT IS BROKEN BECAUSE OF THE NEW IMPLEMENTATION OF MODELVIEWSET
# NOTE: USING ROUTE TO CREATE THE ENDPOINTS OF THE VIEWSETS
# NOTE: REMOVED THE CUSTOMIZE DELETE IN ModelViewSet, USE 'DESTROY' INSTEAD OF DELETE (ONLY IN GENERIC VIEWSETS) 
# NOTE: WATCH LESSON 26 PART 2. TIME STAMP: 5:20

# ------------------------------------------------------

# ROUTER

- from rest_framework.routers import DefaultRouter   --------- WITH ROOT END POINT        # localhost:8000/clinic/
- from rest_framework.routers import SimpleRouter    --------- WITHOUT ROOT END POINT

router = DefaultRouter()
router.register('package', views.PackageViewSet) # endpoint - views
router.register('patient', views.PatientViewSet)

urlpatterns = router.urls

# IF YOU HAVE SPECIFIC URL PATTERNS

urlpatterns = [
    path('', include(router.urls)),
    ...
]

# ------------------------------------------------------

# Building API

- create model
- create serializer
- create view
- register route

# ------------------------------------------------------
