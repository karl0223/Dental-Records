# ------------------------------------------------------
# Installing Django Rest Framework
- pipenv install djangorestframework
- add 'rest_framework' in the INSTALLED_APPS

# ------------------------------------------------------
# Creating API views
- create a urls.py file
- In views create a function
- register the route in urls.py

- from rest_framework.decorators import api_view
- from rest_framework.response import Response
- @api_view()
    def product_list(request):
        return Response('ok')

- Flow: create views then add it in urls.py (route)

# ------------------------------------------------------
# Creating Serializers
- Converts a model instance to a dictionary
- search django rest framework serializers for more information

- create serializers.py file in the app
- from rest_framework import serializers
- it is like defining a model with fields (make sure it is the same fields with the model)

# ------------------------------------------------------
# Serializing Objects

# The default object result presentation is in String. Add COERCE_DECIMAL_TO_STRING to convert decimal value fields from string to decimal
- In settings
- REST_FRAMEWORK = {
    'COERCE_DECIMAL_TO_STRING': False
}

# Get object return 404 if not found
- from django.shortcuts import get_object_or_404 # used to get the object and return 404 if not found
- set many to True to iterate over the queryset (many=True)
- serializer = PackageSerializer(queryset, many=True)

# ------------------------------------------------------

# Creating Custom Serializer Fields

- create a new field -- Use serializers.SerializerMethodField(method_name='')
    price_with_discount = serializers.SerializerMethodField(method_name='calculate_discount')

- create a function add put it in the method name
    def calculate_discount(self, package):
        return package.price - (package.price * Decimal(.10))

# To rename a field make the source of the field to its real field name in the model
    package_price = serializers.DecimalField(max_digits=10, decimal_places=2, source='price') -- price -> package_price, source='price'


# ------------------------------------------------------

# Serializing Relationships

- Watch lesson 13 in Django Part 2
- 4 ways to serialize Relationships
- Primary key
- String
- Nested Object
- Hyperlink (complicated)

# ------------------------------------------------------

# Model Serializer

- better implementation of Serializer

- class PackageSerializer(serializers.ModelSerializer):
    class Meta:
        model = Package
        fields = ['title', 'package_type', 'price', 'price_with_discount']

# ------------------------------------------------------

# Deserializing Data and Saving Objects

 - Adding get, put, patch, delete in @api_view(['GET', 'PUT'])
 - check if request.method is equal to the CRUD operations -- if request.method == "GET":
 - serializer.is_valid(raise_exception=True) # Deserializing Data
 - serializer.save() # Save the data
 - return Response(serializer.data, status=status.HTTP_200_OK)

# ------------------------------------------------------

# DELETING OBJECTS

- get the item e.g package = get_object_or_404(Package, pk=id)
- if request.method == 'DELETE':
- package.delete()
- return Response(status.HTTP_204_NO_CONTENT)

# If the object cannot be deleted, check the object if it is associated with other collections/Relationships

# ------------------------------------------------------

# ADVANCED API CONCEPTS

- Class-based views
- Generic views
- Viewsets
- Routers
- Searching, filtering and pagination

# ------------------------------------------------------

# API Views

- from rest_framework.views import APIView
- converting function based view into Class based views
- change the path in urls.py --- path('package/', views.PackageList.as_view())
- check views.py for the changes

# ------------------------------------------------------

# Model Mixins

- from rest_framework.mixins import ListModelMixin, CreateModelMixin
- Improved class based views
- check the mixins implementation for more information -- lesson 22 in django part 2

- didn't use the model mixins
- uses generic views (better version)

# ------------------------------------------------------

# Generic Views

- from rest_framework.generics import ListCreateAPIView
- search search django rest_framework api guide generic views
- Use Concrete View Classes
- Concrete class combines 2 or more mixins

# ListCreateAPIView

# Basic Implementation

- queryset = Package.objects.all()
- serializer_class = PackageSerializer

# overwrite the get_queryset and get_serializer_class, and get_serializer_context --- USE IF YOU HAVE A LOGIC NEEDED E.G IF CONDITIONS

- def get_queryset(self):
    return Package.objects.all()
    
- def get_serializer_class(self):
    return PackageSerializer            #class -- remove the () - with parenthesis, it's a function

- def get_serializer_context(self):
        return {'request': self.request} - return the context object

- You can now delete the 'get' and 'post' function because ListCreateAPIView has a built in list and create api views
- much cleaner and much conscise compared to base APIView

# Note: IF YOU HAVE A CUSTOM FIELD LIKE 'Products_Count' IN THE SERIALIZER MAKE IT 'read_ony=True' TO AVOID PROBLEM

- products_count = serializer.IntegerField(read_ony=True)

# ------------------------------------------------------

# Customizing Generic Views

- from rest_framework.generics import ListCreateAPIView, RetrieveUpdateDestroyAPIView
- check the implementation of each class, if it can get, patch, put, delete

- In urls.py, if you encounter an error URL keyword argument named 'pk'. Change the 'path('package/<int:pk>/', views.PackageDetail.as_view())' 
    or add (lookup_field = 'id') in the class views IF <int:id> ---- path('package/<int:id>/', views.PackageDetail.as_view())
- use 'pk' instead of 'id'


# To customize the generic view

- overwrite the existing function like the delete
- def delete(self, request, id):
        package = get_object_or_404(Package, pk=id)
        package.delete()
        return Response(status=status.HTTP_204_NO_CONTENT)

# ------------------------------------------------------

# Model View Set -- Single class end point (CRUD endpoints)

- from rest_framework.viewsets import ModelViewSet

- has multiple APIView like get, retrieve, update and delete
- used to combine the logic of multiple views
- analyze the changes in views.py. The PackgeList and PackageDetail are combined using model view set

# IF YOU DONT NEED WRITE OPERATIONS (PUT, PATCH, POST, DELETE) ONLY 'GET' METHOD

- from rest_framework.viewsets import ReadOnlyModelViewSet
- read only operations

# NOTE: THE PACKAGE ENDPOINT IS BROKEN BECAUSE OF THE NEW IMPLEMENTATION OF MODELVIEWSET
# NOTE: USING ROUTE TO CREATE THE ENDPOINTS OF THE VIEWSETS
# NOTE: REMOVED THE CUSTOMIZE DELETE IN ModelViewSet, USE 'DESTROY' INSTEAD OF DELETE (ONLY IN GENERIC VIEWSETS) 
# NOTE: WATCH LESSON 26 PART 2. TIME STAMP: 5:20

# ------------------------------------------------------

# ROUTER

- from rest_framework.routers import DefaultRouter   --------- WITH ROOT END POINT        # localhost:8000/clinic/
- from rest_framework.routers import SimpleRouter    --------- WITHOUT ROOT END POINT

router = DefaultRouter()
router.register('package', views.PackageViewSet) # endpoint - views
router.register('patient', views.PatientViewSet)

urlpatterns = router.urls

# IF YOU HAVE SPECIFIC URL PATTERNS

urlpatterns = [
    path('', include(router.urls)),
    ...
]

# ------------------------------------------------------

# Building API

- create model
- create serializer
- create view
- register route

# ------------------------------------------------------

# Nested Routers

- pipenv install drf-nested-routers

- from rest_framework_nested import routers

- router = routers.DefaultRouter()
- router.register('branches', views.BranchViewSet)

- branches_router = routers.NestedDefaultRouter(router, 'branches', lookup='branch') # parent router - parent prefix - lookup parameters (branch_pk)
- The NestedDefaultRouter output will be ------- localhost:8000/clinic/branches/{branch_pk}/reviews/{pk}

- branches_router.register('reviews', views.ReviewViewSet, basename='branch-reviews') # branch-reviews-list / branch-reviews-detail

- urlpatterns = router.urls + branches_router.urls

- check the serializer and views.py on how to manipulate the data by overwritting the 'create, get queryset and get_serializer_context'

# ------------------------------------------------------

# FILTERING

- filter specific object
- route + ?parameters
- localhost:8000/clinic/package?collection_id=#

- self.request.query_params.get('package_id')      # GET THE QUERY PARAMS IN THE REQUEST  -- ?package_id=8

class PatientViewSet(ModelViewSet):
    serializer_class = PatientSerializer

    def get_queryset(self):
        queryset = Patient.objects.all()
        package = self.request.query_params.get('package')
        if package is not None:
            queryset = queryset.filter(package=package)
        return queryset

# ADD BASENAME TO THE ROUTE
- router.register('patients', views.PatientViewSet, basename='patients')

# ------------------------------------------------------

# Generic Filtering

- pipenv install django-filter

- In INSTALLED_APPS add 'django-filters'

- from django_filters.rest_framework import DjangoFilterBackend

- filter_backends = [DjangoFilterBackend]
- filterset_fields = ['package_id']       # filter the package_id --- same result with the get_queryset but better

- using filter_backends and filterset_fields you can now remove the get_queryset and set again the 'queryset = Patient.objects.all()'

def get_queryset(self):
        queryset = Patient.objects.all()
        package_id = self.request.query_params.get('package_id')
        if package_id is not None:
            queryset = queryset.filter(package_id=package_id)
        return queryset

- ADDED A FILTER BUTTON
- Check the django-filter documentation for more information
- you can create custom filter etc

# Better implementation of filterset_fields

- create a filter.py
- from django_filters import FilterSet
- check the filter.py for the implementation

- create the 'PatientFilter' class
- add 'filterset_class = PatientFilter' in the PatientViewSet

# ------------------------------------------------------

# Searching

- for text based field

- from rest_framework.filters import SearchFilter
- filter_backends = [SearchFilter]
- search_fields = ['first_name', 'last_name']    # case insensitive

# ------------------------------------------------------

# Sorting

- from rest_framework.filters import OrderingFilter
- filter_backends = [OrderingFilter]
- ordering_fields = ['balance', 'registration_date']

# ------------------------------------------------------

# Pagination

- two ways to implement pagination. PageNumberPagination is the common approach

# PageNumberPagination
- from rest_framework.pagination import PageNumberPagination

# LimitOffsetPagination
- from rest_framework.pagination import PageNumberPagination


# SET PAGINATION TO SPECIFIC VIEW SET

- add 'pagination_class = PageNumberPagination' in the ViewSet    # e.g PatientViewSet

# SET THE PAGE SIZE IN SETTINGS 'REST_FRAMEWORK'

REST_FRAMEWORK = {
    'COERCE_DECIMAL_TO_STRING': False,
    'PAGE_SIZE': 10
}


# TO SET THE PAGINATION GLOBALLY 

- remove the 'pagination_class = PageNumberPagination' in the ViewSet

REST_FRAMEWORK = {
    'COERCE_DECIMAL_TO_STRING': False,
    'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.PageNumberPagination',
    'PAGE_SIZE': 10
}

# SET PAGINATION TO SPECIFIC VIEW SET AND REMOVE THE ERROR 'DEFAULT PAGE SIZE PAGINATION IN REST_FRAMEWORK SETTINGS'

- remove the page size in the REST_FRAMEWORK

REST_FRAMEWORK = {
    'COERCE_DECIMAL_TO_STRING': False,
}

- create a new file. pagination.py

- from rest_framework.pagination import PageNumberPagination

class DefaultPagination(PageNumberPagination):
    page_size = 10

- add 'pagination_class = DefaultPagination' in the View Set

# ------------------------------------------------------

# IMPROVEMENT IN MODELS

# GUIID

- Globally Unique identifier

- from uuid import uuid4

class test(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid4)

# UNIQUE FIELDS

class Meta:
    unique_together = [['cart', 'product']]      # list of list

# ------------------------------------------------------

# Create Custom View Set 

- lesson 37 part 2

- from rest_framework.mixins import CreateModelMixin
- from rest_framework.viewsets import GenericViewSet

class CartViewSet(CreateModelMixin, GenericViewSet):    # used to specify needed operations 'GET' etc
    ...

# Make UUIDField read only

class CartSerializer(serializer.ModelSerializer):
    id = serializer.UUIDField(read_only=True)
    ...

# ------------------------------------------------------
